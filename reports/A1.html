<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>15-472-s24: A1 - Scene Graph</title>
<style>
/* feel free to style your report in a fancier way! */

@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;400;700&Anonymous+Pro&display=swap');

html {
	background:#505055;
}

body {
	font-family: 'Quicksand', sans-serif;
	color:#000;
	background:#eeeee8;
	font-size:15px;
	margin: 1em auto 50vh auto;
	padding: 1em 2em 1em 2em;
	max-width:45em;
	border-radius:4px;
	box-shadow:0 0 10px #0008;
}

h1 { font-size: 20px; font-weight: 700; }
h2 { font-size: 16px; font-weight: 700; }
h3 { font-size: 16px; font-weight: 400; }
h4 { font-size: 14px; font-weight: 400; }

h1, h2, h3, h4 {
	margin: 15px 0 0 -10px;
}

p {
	margin: 5px 0 0 0;
}

.subtitle {
	display:block;
	font-size:16px;
	font-weight:400;
}

.placeholder {
	color:#800;
	font-style:italic;
}

.answer {
	color:#373737;
}

kbd {
	display:inline-block;
	background:#ccc;
	color:#444;
	font-style:normal;
	font-weight:700;
	border-radius:8px;
	padding:1px 6px;
	margin:1px;
	border:1.5px solid #aaa;
}

code {
	font-family: 'Anonymous Pro', monospace;
	background: #222;
	color:#fff;
	border-radius:4px;
	padding:2px 4px;
	margin:1px;
}

code var {
	color:#ef5;
	font-style:italic;
}

video {
	display:block;
	margin: 10px auto;
	max-width:100%;
	border-radius:4px;
	box-shadow:0 0 5px #0008;
}

.atag {
	font-family: 'Calistoga', serif;
	font-size:90%;
	color:#000;
	background:#e17dcd;

	display:inline-block;
	padding:1px 4px;
	border-radius: 4px;
	line-height:120%;
}
.atag:before {
	content:'»';
}
.atag.extra {
	background:#c6aff8;
}
.atag.creative {
	background:linear-gradient(0.35turn, #fcacff, #f9ab93, #76a1e4, #20953d);
}

</style>
</head>
<body>
<h1>A1: Scene Viewer
<span class="subtitle">by <span class="placeholder">Jim McCann (jmccann)</span></span>
</h1>

<!-- of course, delete these class="placeholder" notes in your report: -->

<p class="placeholder">
Summarize, in about one paragraph, your approach to the scene graph assignment.
How did you structure your code?
What's cool about it? Are there parts you weren't able to complete?
</p>

<h2>My Animation <span class="atag creative">A1-create</span></h2>

<p class="placeholder">
Describe your animation and include a screen recording showing it running in real-time:
</p>

<video>
<!--
  you can use the 'video' element to show your code running
  Learn more at:
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video

  Example: put the video file in a path near this .html
  <source src="path/to/video" type="video/mp4" />
-->
</video>

<p class="placeholder">
Describe how you created your animation.
</p>

<h2>Using the Scene Viewer</h2>

<p class="placeholder">Provide a short overview of how to use your viewer.</p>

<h3>Command-line Arguments</h3>

<p class="placeholder">
Document the command-line arguments that can be used to control your viewer.
Include both the command-line arguments required by the assignment statement and any additional arguments you decided to add.
</p>

<ul>
<li class="placeholder"><code>--scene <var>scene.s72</var></code> -- required -- load scene from <code><var>scene.s72</var></code></li>
<li class="placeholder">...</li>
</ul>

<h3>Controls</h3>

<p class="placeholder">
Document the keyboard and mouse controls used to control your viewer when run interactively.
Note that the controls below are placeholders not requirements.
</p>

<ul>
<li class="placeholder"><kbd>LMB+Drag</kbd> orbit the camera.</li>
<li class="placeholder"><kbd>TAB</kbd> switch cameras.</li>
<li class="placeholder">...</li>
</ul>


<h2>Evidence</h2>

<p class="placeholder">
The purpose of this section is to get you to think critically about your code by providing evidence sufficient to demonstrate to course staff that it works.
These thoughts may also help you improve the code as you work on it in A2 and beyond.
</p>


<h3>Scene Loading <span class="atag">A1-load</span></h3>

<p class="placeholder">
Describe, in a few sentences, how your loading code works.
Reference function and structure names for us to examine.
</p>

<p class="answer">
The S72::load() function is adapted from the example code. It uses the sejp library to parse the .s72 JSON file into an intermediate S72 struct, which is also adapted from the example code. It iterates through the array converted from JSON, parse each object based on the "type" field and save them into corresponding data structures in the S72 struct. After parsing, binary mesh data files (.b72) referenced by meshes are read and loaded into DataFile::data vectors.
</p>

<p class="answer">
The S72::process_meshes() function then iterates over all meshes, extracting vertex attributes from the raw binary data saved in DataFile using their offset/stride information, and pools them into a std::vector<PosNorTexTanVertex> as part of the S72 struct. Each mesh records its first_vertex index into this pooled buffer, which is similar to how ObjectVertices stores the first vertex for each object.
</p>

<p class="answer">
Finally, in main.cpp, the pooled vertices are uploaded to a device-local Vulkan buffer (s72_vertices) for later GPU rendering, similar to how object_vertices was created.
</p>

<p class="placeholder">
(If you have <span class="atag">A1-show</span> working, you don't need to provide further evidence here. If you do not, provide some sort of print-outs or other scene statistics to prove that your code can load s72 scenes.)
</p>

<h3>Scene Display <span class="atag">A1-show</span></h3>
<p class="placeholder">
Describe, in a few sentences, how your display code goes from your internal scene graph representation to triangles being drawn by the GPU.
Provide function and structure names for us to examine.
</p>

<p class="answer">
The S72 struct holds parsed scene data (nodes, meshes, cameras) in DataFile. In Tutorial::update(), a recursive traverse() lambda function walks the scene graph from s72.scene.roots, computing world transforms by multiplying parent × local (Translation * Rotation * Scale) matrices.
</p>

<p class="answer">
For each node with a mesh, an ObjectInstance is created containing the S72::Mesh* pointer and ObjectsPipeline::Transform matrices (CLIP_FROM_LOCAL, WORLD_FROM_LOCAL, WORLD_FROM_LOCAL_NORMAL).
</p>

<p class="answer">
For each node with a camera, an SceneCamera is created containing the S72::Camera* pointer and the WORLD_FROM_LOCAL matrix.
</p>

<p class="answer">
When loading the s72 scene, all vertices are pooled into std::vector<PosNorTexTanVertex> vertices. 
</p>

<p class="answer">
In Tutorial constructor, those vertices data is copied into the object_vertices vertex buffer, bound to binding = 0, 
</p>

<p class="answer">
In Tutorial::render(), transforms are uploaded to the GPU Transforms buffer. Each ObjectInstance is drawn via vkCmdDraw(cmd, mesh->count, 1, mesh->first_vertex, index) using the pooled object_vertices buffer.
</p>

<p class="placeholder">
Provide evidence that your code can display s72 scenes.
Good evidence: screen shots or movies showing that example scene files load correctly.
Choose or generate example scene files sufficient to demonstrate all required features (note that the simplifying assumptions in the assignment mean you do not need to completely implement s72).
</p>
<p class="placeholder">
Spend some time thinking about corner cases that the provided examples may not test.
If you develop a test case for these, include the s72 and b72 files with your report as well.
</p>

<p class="answer">
Created example-more-cameras.s72 with five cameras, including two edge-case cameras with extreme near/far clippings for testing the frustum drawing.
</p>

<h3>Scene Display &mdash; Interaction <span class="atag">A1-show</span></h3>

<p class="placeholder">
Describe how your code handles camera handling and switching.
</p>

<p class="answer">
Three camera modes are supported via the CameraMode enum: Scene, User, and Debug.
</p>

<p class="answer">
Scene mode: Uses cameras from the S72 scene graph. During traversal, camera nodes are collected with their world transforms and projection settings and stored into a vector of SceneCamera structs. Users can cycle between scene cameras with Space key.
</p>

<p class="answer">
User mode: An OrbitCamera controlled by mouse (drag to rotate, scroll to zoom) and keyboard. Computes view matrix via the orbit() function.
</p>

<p class="answer">
Debug mode: Renders from a second user-controlled OrbitCamera while displaying the previously-active camera's frustum as yellow lines. Frustum corners are computed by transforming clip-space points through CLIP_FROM_WORLD_CULLING, which stores the previously-active camera’s CLIP_FROM_WORLD.
</p>

<p class="answer">
Camera switching uses keys 1/2/3, with --camera flag setting the initial mode.
</p>

<p class="placeholder">
Provide evidence that these interactions work.
Possible evidence: a screen recording showing debug, user, and scene camera switching and interactive movement of the debug and user cameras.
</p>

<video><source src="A1-show-1.mp4" type="video/mp4" /></video>

<h3>Frustum culling <span class="atag">A1-cull</span></h3>

<p class="placeholder">
Describe, in a few sentences,
where your culling test is implemented;
how you computed bounding boxes and the camera frustum;
and the approach you used in your box-frustum test (draw and include a picture if it makes your explanation easier).
Include references to specific functions and structures in your code for us to examine further.
</p>
<p class="placeholder">
Include, as evidence, a screenshot or video showing that culling is working (e.g., by using a debug camera to show that meshes outside the user camera's view aren't being drawn).
</p>

<p class="placeholder">
Also include evidence that your culling works on any particularly difficult cases you may have thought up (include .s72 / .b72 files as appropriate).
</p>

<p class="placeholder">
Demonstrate a scene and camera angle where your culling code improves performance; and demonstrate one where it does not improve performance.
Include screen shots and make a chart or graph of median frame times as evidence for the performance impact.
</p>


<h3>Animating the scene <span class="atag">A1-move</span></h3>

<p class="placeholder">
Describe, in a few sentences:
how your viewer stores keyframes;
and where/how your code handles updated transformations due to animations.
Include code and structure references.
</p>

<p class="placeholder">
Provide evidence that your viewer can play back s72 animation.
Make sure to demonstrate that both camera and object animation work, and that animation of scene graph hierarchies work.
</p>


<h3>Bottleneck Hunting <span class="atag">A1-test</span></h3>

<p class="placeholder">
Describe for your CPU- and GPU-bottlenecked scenes what your approach was to moving the critical part of the workload to the CPU or GPU, respectively.
Include a screenshot of the scenes as well as s72 and b72 files as needed.
</p>
<p class="placeholder">
Describe how you generated the scenes.
</p>
<p class="placeholder">
Describe how you tested the scenes -- including any relevant hardware information about the computer(s) you tested on.
</p>
<p class="placeholder">
Provide evidence that in each scene the CPU- or GPU-part of the workload is, indeed, a bottleneck.
Use charts and graphs as appropriate to make your argument.
</p>


<h3>Performance improvements <span class="atag extra">A1x-fast</span></h3>
<p class="placeholder">
Write a subsection (&lt;h4&gt;) of this section for every attempted performance improvement.
If you attempted no further performance improvements leave this section blank.
</p>

<p class="placeholder">
In each subsection, include a description of what you tried (including references to your code) and evidence of where (and if) the optimization actually did improve performance.
Report -- at a minimum -- frame times for the same scene collected in headless mode with the optimization on and off.
Ideally, develop a scene for which the optimization does improve performance and another scene for which it does not.
</p>

<h2>Feedback</h2>
<p class="placeholder">
This is the end of the structured report. Feel free to add feedback about A1 to this section.
</p>

</body>
</html>
